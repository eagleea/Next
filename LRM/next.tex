\documentclass[12pt]{article}

\begin{document}

\title{\textbf{Next} \\ Language Reference Manual}
\author{Ernesto Arreguin (eja2124) \\Danny Park (dsp2120) \\Morgan Ulinski (mu2189) \\Xiaowei Zhang (xz2242)}
\date{}
\maketitle

\pagebreak

\tableofcontents

\section{Introduction}
TODO

\section{Lexicon}
The Next programming language uses a standard grammar and character set.  Characters in the source code are grouped into tokens, which can be punctuators, operators, identifiers, keywords, or string literals.  The compiler forms the longest possible token from a given string of characters; tokens end when white space is encountered, or when it would not be possible for the next character to be part of the token.  White space is defined as space characters, tab characters, return characters, and newline characters.
\\
\\
\noindent The compiler processes the source code and identifies tokens and locates error conditions.  There are three types of errors:
\begin{itemize}
\item Lexical errors occur when the compiler cannot form a legal token from the character stream.
\item Syntax errors occur when a legal token can be formed, but the compiler cannot make a legal statement from the tokens.
\item Semantic errors, which are grammatically correct and thus pass through the parser, but break another Next rule.  For example, it is possible to \texttt{kill} a character or item, but not a location.
\end{itemize}

\subsection{Character Set}
The Next programming languages accepts standard ASCII characters.

\subsection{Identifiers}
An identifier is a sequence of characters that represents a name for a:
\begin{itemize}
\item Variable
\item Location
\item Character
\item Item
\item Action \\
\end{itemize}

\noindent Rules for identifiers:
\begin{itemize}
\item Identifiers consist of a sequence of one or more uppercase or lowercase characters, the digits 0 to 9, and the underscore character (\_).
\item Identifier names are case sensitive.
\item Identifiers cannot begin with a digit or an underscore.
\item Keywords are not identifiers.
\end{itemize}

\subsection{Comments}
Comments are introduced by /* and ended by */, except within a string literal.
Comments cannot be nested.  If a comment is started by /*, the next occurrence of */ ends the comment.

\subsection{Keywords}
Keywords identify statement constructs and specify basic types.  Keywords cannot be used as identifiers.  The keywords are listed in Table~\ref{keywords}.

\begin{table}[htdp]
\caption{Keywords}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\texttt{if} & \texttt{then} & \texttt{else} & \texttt{and} & \texttt{or} \\
\hline
\texttt{start} & \texttt{end} & \texttt{when} & \texttt{choose} & \texttt{kill} \\
\hline
\texttt{grab} & \texttt{hide} & \texttt{exists} & \texttt{drop} & \texttt{output} \\
\hline
\texttt{character} & \texttt{location} & \texttt{action} & \texttt{item} & \texttt{int} \\
\hline
\texttt{string} & \texttt{next} & & &  \\
\hline
\end{tabular}
\end{center}
\label{keywords}
\end{table}%

\noindent Keywords are used:
\begin{itemize}
\item To qualify a data type (\texttt{character, location, action, item, int, string})
\item As part of a statement (\texttt{if, then, else, and, or, start, end, when, choose, kill, grab, hide, exists, drop, output}) 
\end{itemize}


\subsection{Operators}
Operators are tokens that specify an operation on at least on operand and yield a result (a value, side effect, or combination).  Operands are expressions.  Operators with one operand are unary operators, and operators with two operands are binary operators.
\\
\\
\noindent Operators are ranked by precedence, which determines which operators are evaluated before others in a statement.
\\
\\
\noindent Some operators are composed of more than one character, and others are single characters.
\\
\\
\noindent The single character operators are shown in Table~\ref{single_operators}.

\begin{table}[htdp]
\caption{Single-character operators}
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
\texttt{+} & \texttt{-} & \texttt{*} & \texttt{/} & \texttt{<} \\
\hline
\texttt{>} & \texttt{=} & \texttt{} & \texttt{} & \texttt{"} \\
\hline
\texttt{.} & \texttt{\{} & \texttt{\}} & \texttt{(} & \texttt{)} \\
\hline
\end{tabular}
\end{center}
\label{single_operators}
\end{table}%


\noindent The multiple-character operators are shown in Table~\ref{multi_operators}.

\begin{table}[htdp]
\caption{Multiple-character operators}
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|}
\hline
\texttt{>=} & \texttt{<=} & \texttt{==} & \texttt{!=} & \texttt{and} & \texttt{or} \\
\hline
\end{tabular}
\end{center}
\label{multi_operators}
\end{table}%

\subsection{Punctuators}
Table~\ref{punctuators} shows the punctuators in Next.  Each punctuator has its own syntactic and semantic significance.  Some characters can either be punctuators or operators; the context specifies the meaning.

\begin{table}[htdp]
\caption{Punctuators}
\begin{center}
\begin{tabular}{|c|c|}
\hline
\{ \} & Declaration block or compound statement delimiter \\
\hline
( ) & Sub-declaration list; also used in expression grouping \\
\hline
, & Sub-declaration separator \\
\hline
; & Statement end \\
\hline
= & Declaration initializer \\
\hline 
`` " & String literal \\
\hline
\end{tabular}
\end{center}
\label{punctuators}
\end{table}%

\subsection{String and integer literals}
Strings are sequences of zero or more characters.  String literals are character strings surrounded by quotation marks.  String literals can include any valid character, including white-space characters.

Integers are used to represent whole numbers.  Next does not support floating point numbers.  Integers are specified by a sequence of decimal digits.  The value of the integer is computed in base 10.

\section{Basic Concepts}

\subsection{Blocks}
A block is a section of code surrounded by braces \{ \}.  Blocks are used to surround compound statements, a set of related statements enclosed in braces.   Since Next uses global scope (except in the case of actions), blocks do not affect the scope of a variable.

\subsection{Scope}
All declarations except actions are made at the beginning of the program, and have global scope.  Actions are declared within a choose statement and their scope is that choose statement.

\subsection{Side Effects and Sequence Points}
Any operation that affects an operand's storage has a side effect.  This includes the assignment operation, and operations that alter the items, attributes, etc. within a location or a character.

Sequence points are checkpoints in the program where the compiler ensures that operations in an expression are concluded.  The most important example of this is the semicolon that marks the end of a statement.  All expressions and side effects are completely evaluated when the semicolon is reached.


\section{Data Types}
A type is assigned to an object in its declaration.  Table~\ref{types} shows the basic types that are used in Next.

\begin{table}[htdp]
\caption{Basic Data Types}
\begin{center}
\begin{tabular}{|c|c|}
\hline
integer \\
\hline
string \\
\hline
location \\
\hline
character \\
\hline
item \\
\hline
(attribute) \\
\hline
(action) \\
\hline
\end{tabular}
\end{center}
\label{types}
\end{table}%


\section{Declarations}
Declarations introduce identifiers (variable names) in the program, and, in the case of the complex types (character, location, item), specify important information about them such as attributes.  When an object is declared, space is immediately allocated for it.

\subsection{Primitive Types}
The primitive types in Next are integer and string.  These can stand on their own, or they can serve as attributes within a complex type.  Primitive types are declared as follows: \\

\texttt{int \textit{identifier} = \textit{value}}

\texttt{string \textit{identifier} = \textit{value}} \\

\noindent where:
\begin{itemize}
\item \texttt{identifier} stands in for a variable name.
\item \texttt{value} stands in for an expression.
\end{itemize}

\subsection{Complex Types}
Each of the complex types in Next (item, character, and location) has its own declaration syntax.  The declarations are as follows: \\

\texttt{item \textit{identifier} = \{ \textit{primitive\_declaration\_list} \}} \\

\texttt{character \textit{identifier} = \{ \textit{primitive\_declaration\_list}, \\
\indent \indent \indent \indent \indent \indent \indent \indent \indent \indent  \textit{item\_list} \} } \\

\texttt{location \textit{identifier} = \{ \textit{primitive\_declaration\_list}, \\
\indent \indent \indent \indent \indent \indent \indent \indent \indent \indent  \textit{item\_list}, \\
\indent \indent \indent \indent \indent \indent \indent \indent \indent \indent  \textit{character\_list} \}} \\

\noindent where:
\begin{itemize}
\item \texttt{identifier} stands in for a variable name.
\item \texttt{primitive\_declaration\_list} stands in for a list of attribute declarations in the form \texttt{(declaration\_1, declaration\_2, ... , declaration\_n)}, and each \texttt{declaration} is in the form described above in the description of primitive types.  These represent the attributes (and values for those attributes) for a given item, character, or location.
\item \texttt{item\_list} and \texttt{character\_list} stand in for lists of item and character variable names, respectively, in the form \texttt{(name\_1, name\_2, ... name\_n)}.  These represent the list of items a character is carrying or are found in a location, and the characters that are physically in a location.
\end{itemize}

\section{Expressions and Operators}
An expression is a sequence of Next operators and operands that produces a value or generates a side effect.  The simplest expressions yield values directly, such as ints, strings, and variable names.  Other expressions combine operators and subexpressions to produce values.  Every expression has a type as well as a value.  Operands in expressions must have compatible types.

\subsection{Primary Expressions}
\subsection{Overview of the Next Operators}
\subsection{Unary Operators}
\subsection{Binary Operators}

\section{Statements}
\subsection{Labeled Statements}
\subsection{Compound Statements}
\subsection{Expression Statements}
\subsection{Selection Statements}
\subsection{Iteration Statements}

\section{Examples}


\end{document}
